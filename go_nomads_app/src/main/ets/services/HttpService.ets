import { http } from '@kit.NetworkKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { ApiConfig } from '../common/constants/ApiConfig';
import { TokenStorageService } from './TokenStorageService';

const TAG = 'HttpService';
const DOMAIN = 0x0001;

/**
 * API ÂìçÂ∫îÂÖÉÊï∞ÊçÆ
 */
export interface ApiResponseMeta {
  success: boolean;
  message: string;
  errors: string[];
  statusCode?: number;
}

/**
 * API Áªü‰∏ÄÂìçÂ∫îÂåÖË£Ö
 */
export interface ApiResponse<T = object> {
  success: boolean;
  message: string;
  data: T;
  errors?: string[];
}

/**
 * HTTP ËØ∑Ê±ÇÈÖçÁΩÆ
 */
export interface RequestOptions {
  /** ËØ∑Ê±ÇÂ§¥ */
  headers?: Record<string, string>;
  /** Êü•ËØ¢ÂèÇÊï∞ */
  queryParams?: Record<string, string>;
  /** ÊòØÂê¶Á¶ÅÁî® API ÂìçÂ∫îËß£ÂåÖ */
  disableUnwrap?: boolean;
  /** Ë∂ÖÊó∂Êó∂Èó¥(ÊØ´Áßí) */
  timeout?: number;
}

/**
 * HTTP ÊúçÂä° - ÂØπÂ∫î Flutter Á´Ø http_service.dart
 * Âü∫‰∫éÈ∏øËíô @kit.NetworkKit Â∞ÅË£Ö
 */
export class HttpService {
  private static instance: HttpService | null = null;
  private isRedirectingToLogin: boolean = false;

  /** 401 ‰∫ã‰ª∂ÂõûË∞ÉÔºåÁî±Â§ñÈÉ®ËÆæÁΩÆ‰ª•Â§ÑÁêÜË∑≥ËΩ¨ÁôªÂΩïÁ≠âÈÄªËæë */
  onUnauthorized: (() => void) | null = null;

  private constructor() {
  }

  static getInstance(): HttpService {
    if (!HttpService.instance) {
      HttpService.instance = new HttpService();
    }
    return HttpService.instance;
  }

  // ============================================================
  // ÂÖ¨ÂÖ±ËØ∑Ê±ÇÊñπÊ≥ï
  // ============================================================

  /** GET ËØ∑Ê±Ç */
  async get<T>(endpoint: string, options?: RequestOptions): Promise<T> {
    return this.request<T>('GET', endpoint, undefined, options);
  }

  /** POST ËØ∑Ê±Ç */
  async post<T>(endpoint: string, data?: object, options?: RequestOptions): Promise<T> {
    return this.request<T>('POST', endpoint, data, options);
  }

  /** PUT ËØ∑Ê±Ç */
  async put<T>(endpoint: string, data?: object, options?: RequestOptions): Promise<T> {
    return this.request<T>('PUT', endpoint, data, options);
  }

  /** DELETE ËØ∑Ê±Ç */
  async delete<T>(endpoint: string, options?: RequestOptions): Promise<T> {
    return this.request<T>('DELETE', endpoint, undefined, options);
  }

  /** PATCH ËØ∑Ê±Ç */
  async patch<T>(endpoint: string, data?: object, options?: RequestOptions): Promise<T> {
    return this.request<T>('PATCH', endpoint, data, options);
  }

  // ============================================================
  // Ê†∏ÂøÉËØ∑Ê±ÇÂÆûÁé∞
  // ============================================================

  private async request<T>(
    method: string,
    endpoint: string,
    data?: object,
    options?: RequestOptions
  ): Promise<T> {
    const startTime = Date.now();
    const url = this.buildFullUrl(endpoint, options?.queryParams);

    // ÊûÑÂª∫ËØ∑Ê±ÇÂ§¥ (ArkTS ‰∏çÊîØÊåÅ spread ËøêÁÆóÁ¨¶)
    let headers: Record<string, string> = {};
    headers['Content-Type'] = 'application/json';
    headers['Accept'] = 'application/json';
    if (options?.headers) {
      const headerKeys = Object.keys(options.headers);
      for (let i = 0; i < headerKeys.length; i++) {
        headers[headerKeys[i]] = options.headers[headerKeys[i]];
      }
    }

    // Ê∑ªÂä†ËÆ§ËØÅ Token
    const tokenService = TokenStorageService.getInstance();
    const token = tokenService.getAccessToken();
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }

    // Ê∑ªÂä†Áî®Êà∑ ID
    const userId = tokenService.getUserId();
    if (userId) {
      headers['X-User-Id'] = userId;
    }

    // HTTP ÊñπÊ≥ïÈáçÂÜô
    let actualMethod = method;
    if (ApiConfig.USE_HTTP_METHOD_OVERRIDE) {
      const upperMethod = method.toUpperCase();
      if (upperMethod === 'PUT' || upperMethod === 'DELETE' || upperMethod === 'PATCH') {
        hilog.debug(DOMAIN, TAG, 'HTTP Method Override: %{public}s -> POST', method);
        headers['X-HTTP-Method-Override'] = upperMethod;
        actualMethod = 'POST';
      }
    }

    hilog.info(DOMAIN, TAG, 'üöÄ REQUEST[%{public}s] => %{public}s', method, url);

    let httpRequest = http.createHttp();
    try {
      const httpMethod = this.mapHttpMethod(actualMethod);

      const response = await httpRequest.request(url, {
        method: httpMethod,
        header: headers,
        extraData: data ? JSON.stringify(data) : undefined,
        connectTimeout: options?.timeout ?? ApiConfig.CONNECT_TIMEOUT,
        readTimeout: options?.timeout ?? ApiConfig.RECEIVE_TIMEOUT,
      });

      const duration = Date.now() - startTime;
      hilog.info(DOMAIN, TAG, '‚úÖ RESPONSE[%{public}d] (%{public}dms) => %{public}s',
        response.responseCode, duration, url);

      // Â§ÑÁêÜ HTTP Áä∂ÊÄÅÁ†Å
      if (response.responseCode === 401) {
        await this.handleUnauthorized();
        throw new Error('Unauthorized: Token expired or invalid');
      }

      if (response.responseCode >= 400) {
        const errorBody = typeof response.result === 'string'
          ? response.result : JSON.stringify(response.result);
        hilog.error(DOMAIN, TAG, '‚ùå HTTP Error %{public}d: %{public}s',
          response.responseCode, errorBody);
        throw new Error(this.extractBackendErrorMessage(response.responseCode, response.result));
      }

      // Ëß£ÊûêÂìçÂ∫î
      let responseData: Object;
      if (typeof response.result === 'string') {
        responseData = JSON.parse(response.result as string) as Object;
      } else {
        responseData = response.result as Object;
      }

      // API ÂìçÂ∫îËß£ÂåÖ
      if (!options?.disableUnwrap && responseData && typeof responseData === 'object') {
        const envelope = responseData as ApiResponse<T>;
        if (envelope.success !== undefined) {
          if (envelope.success) {
            return envelope.data;
          } else {
            const errorMsg = envelope.message || 'Request failed';
            hilog.error(DOMAIN, TAG, '‚ùå API Error: %{public}s', errorMsg);
            throw new Error(errorMsg);
          }
        }
      }

      return responseData as T;
    } catch (err) {
      const duration = Date.now() - startTime;
      const errorMsg = (err instanceof Error) ? err.message : JSON.stringify(err);
      hilog.error(DOMAIN, TAG, '‚ùå REQUEST FAILED (%{public}dms) %{public}s: %{public}s',
        duration, url, errorMsg);
      if (err instanceof Error) {
        throw err;
      }
      throw new Error(errorMsg);
    } finally {
      httpRequest.destroy();
    }
  }

  // ============================================================
  // URL ÊûÑÂª∫
  // ============================================================

  private buildFullUrl(endpoint: string, queryParams?: Record<string, string>): string {
    // Â¶ÇÊûú endpoint Â∑≤ÁªèÊòØÂÆåÊï¥ URL
    if (endpoint.startsWith('http://') || endpoint.startsWith('https://')) {
      return endpoint;
    }

    const baseUrl = ApiConfig.currentApiBaseUrl;
    let url = `${baseUrl}${endpoint}`;

    if (queryParams) {
      const queryString = Object.keys(queryParams)
        .filter(key => queryParams[key] !== undefined && queryParams[key] !== null)
        .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(queryParams[key])}`)
        .join('&');
      if (queryString) {
        url = `${url}?${queryString}`;
      }
    }

    return url;
  }

  /**
   * ÊõøÊç¢Ë∑ØÂæÑÂèÇÊï∞
   * Â¶Ç '/cities/{id}' + { id: '123' } => '/cities/123'
   */
  static replacePathParams(endpoint: string, params: Record<string, string>): string {
    let url = endpoint;
    for (const key of Object.keys(params)) {
      url = url.replace(`{${key}}`, params[key]);
    }
    return url;
  }

  // ============================================================
  // HTTP ÊñπÊ≥ïÊò†Â∞Ñ
  // ============================================================

  private mapHttpMethod(method: string): http.RequestMethod {
    switch (method.toUpperCase()) {
      case 'GET':
        return http.RequestMethod.GET;
      case 'POST':
        return http.RequestMethod.POST;
      case 'PUT':
        return http.RequestMethod.PUT;
      case 'DELETE':
        return http.RequestMethod.DELETE;
      default:
        // PATCH Á≠âÊñπÊ≥ïÈÄöËøá POST + X-HTTP-Method-Override Â§ÑÁêÜ
        return http.RequestMethod.POST;
    }
  }

  private extractBackendErrorMessage(statusCode: number, result: Object | string | number | boolean | ArrayBuffer | null): string {
    let payload: Object | null = null;
    if (typeof result === 'string') {
      try {
        payload = JSON.parse(result) as Object;
      } catch {
        const text = result.trim();
        return text ? `ËØ∑Ê±ÇÂ§±Ë¥•(${statusCode}): ${text}` : `ËØ∑Ê±ÇÂ§±Ë¥•(${statusCode})`;
      }
    } else if (result && typeof result === 'object') {
      payload = result as Object;
    }

    if (payload) {
      const record = payload as Record<string, Object | string | number | boolean | undefined>;
      const message = record['message'];
      if (typeof message === 'string' && message.trim().length > 0) {
        return message;
      }

      const title = record['title'];
      if (typeof title === 'string' && title.trim().length > 0) {
        const errorsObj = record['errors'];
        if (errorsObj && typeof errorsObj === 'object') {
          const errorsRecord = errorsObj as Record<string, Object | string | number | boolean | undefined>;
          const keys = Object.keys(errorsRecord);
          if (keys.length > 0) {
            const first = errorsRecord[keys[0]];
            if (typeof first === 'string' && first.trim().length > 0) {
              return first;
            }
            if (first && typeof first === 'object') {
              const firstObj = first as Record<string, Object | string | number | boolean | undefined>;
              const firstArr = firstObj['0'];
              if (typeof firstArr === 'string' && firstArr.trim().length > 0) {
                return firstArr;
              }
            }
          }
        }
        return title;
      }
    }

    return `ËØ∑Ê±ÇÂ§±Ë¥•(${statusCode})`;
  }

  // ============================================================
  // 401 Â§ÑÁêÜ
  // ============================================================

  private async handleUnauthorized(): Promise<void> {
    if (this.isRedirectingToLogin) {
      return;
    }
    this.isRedirectingToLogin = true;

    hilog.warn(DOMAIN, TAG, 'üî• Token expired or invalid, clearing auth...');

    // Ê∏ÖÈô§ Token
    await TokenStorageService.getInstance().clearAll();

    // Ëß¶ÂèëÂ§ñÈÉ®ÂõûË∞ÉÔºàË∑≥ËΩ¨ÁôªÂΩïÈ°µÁ≠âÔºâ
    if (this.onUnauthorized) {
      this.onUnauthorized();
    }

    // 1ÁßíÂêéÈáçÁΩÆÊ†áÂøó
    setTimeout(() => {
      this.isRedirectingToLogin = false;
    }, 1000);
  }
}
