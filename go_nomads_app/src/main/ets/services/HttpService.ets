import { http } from '@kit.NetworkKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { ApiConfig } from '../common/constants/ApiConfig';
import { TokenStorageService } from './TokenStorageService';

const TAG = 'HttpService';
const DOMAIN = 0x0001;

/**
 * API å“åº”å…ƒæ•°æ®
 */
export interface ApiResponseMeta {
  success: boolean;
  message: string;
  errors: string[];
  statusCode?: number;
}

/**
 * API ç»Ÿä¸€å“åº”åŒ…è£…
 */
export interface ApiResponse<T = object> {
  success: boolean;
  message: string;
  data: T;
  errors?: string[];
}

/**
 * HTTP è¯·æ±‚é…ç½®
 */
export interface RequestOptions {
  /** è¯·æ±‚å¤´ */
  headers?: Record<string, string>;
  /** æŸ¥è¯¢å‚æ•° */
  queryParams?: Record<string, string>;
  /** æ˜¯å¦ç¦ç”¨ API å“åº”è§£åŒ… */
  disableUnwrap?: boolean;
  /** è¶…æ—¶æ—¶é—´(æ¯«ç§’) */
  timeout?: number;
}

/**
 * HTTP æœåŠ¡ - å¯¹åº” Flutter ç«¯ http_service.dart
 * åŸºäºé¸¿è’™ @kit.NetworkKit å°è£…
 */
export class HttpService {
  private static instance: HttpService | null = null;
  private isRedirectingToLogin: boolean = false;

  /** 401 äº‹ä»¶å›è°ƒï¼Œç”±å¤–éƒ¨è®¾ç½®ä»¥å¤„ç†è·³è½¬ç™»å½•ç­‰é€»è¾‘ */
  onUnauthorized: (() => void) | null = null;

  private constructor() {
  }

  static getInstance(): HttpService {
    if (!HttpService.instance) {
      HttpService.instance = new HttpService();
    }
    return HttpService.instance;
  }

  // ============================================================
  // å…¬å…±è¯·æ±‚æ–¹æ³•
  // ============================================================

  /** GET è¯·æ±‚ */
  async get<T>(endpoint: string, options?: RequestOptions): Promise<T> {
    return this.request<T>('GET', endpoint, undefined, options);
  }

  /** POST è¯·æ±‚ */
  async post<T>(endpoint: string, data?: object, options?: RequestOptions): Promise<T> {
    return this.request<T>('POST', endpoint, data, options);
  }

  /** PUT è¯·æ±‚ */
  async put<T>(endpoint: string, data?: object, options?: RequestOptions): Promise<T> {
    return this.request<T>('PUT', endpoint, data, options);
  }

  /** DELETE è¯·æ±‚ */
  async delete<T>(endpoint: string, options?: RequestOptions): Promise<T> {
    return this.request<T>('DELETE', endpoint, undefined, options);
  }

  /** PATCH è¯·æ±‚ */
  async patch<T>(endpoint: string, data?: object, options?: RequestOptions): Promise<T> {
    return this.request<T>('PATCH', endpoint, data, options);
  }

  // ============================================================
  // æ ¸å¿ƒè¯·æ±‚å®ç°
  // ============================================================

  private async request<T>(
    method: string,
    endpoint: string,
    data?: object,
    options?: RequestOptions
  ): Promise<T> {
    const startTime = Date.now();
    const url = this.buildFullUrl(endpoint, options?.queryParams);

    // æ„å»ºè¯·æ±‚å¤´ (ArkTS ä¸æ”¯æŒ spread è¿ç®—ç¬¦)
    let headers: Record<string, string> = {};
    headers['Content-Type'] = 'application/json';
    headers['Accept'] = 'application/json';
    if (options?.headers) {
      const headerKeys = Object.keys(options.headers);
      for (let i = 0; i < headerKeys.length; i++) {
        headers[headerKeys[i]] = options.headers[headerKeys[i]];
      }
    }

    // æ·»åŠ è®¤è¯ Token
    const tokenService = TokenStorageService.getInstance();
    const token = tokenService.getAccessToken();
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }

    // æ·»åŠ ç”¨æˆ· ID
    const userId = tokenService.getUserId();
    if (userId) {
      headers['X-User-Id'] = userId;
    }

    // HTTP æ–¹æ³•é‡å†™
    let actualMethod = method;
    if (ApiConfig.USE_HTTP_METHOD_OVERRIDE) {
      const upperMethod = method.toUpperCase();
      if (upperMethod === 'PUT' || upperMethod === 'DELETE' || upperMethod === 'PATCH') {
        hilog.debug(DOMAIN, TAG, 'HTTP Method Override: %{public}s -> POST', method);
        headers['X-HTTP-Method-Override'] = upperMethod;
        actualMethod = 'POST';
      }
    }

    hilog.info(DOMAIN, TAG, 'ğŸš€ REQUEST[%{public}s] => %{public}s', method, url);

    let httpRequest = http.createHttp();
    try {
      const httpMethod = this.mapHttpMethod(actualMethod);

      const response = await httpRequest.request(url, {
        method: httpMethod,
        header: headers,
        extraData: data ? JSON.stringify(data) : undefined,
        connectTimeout: options?.timeout ?? ApiConfig.CONNECT_TIMEOUT,
        readTimeout: options?.timeout ?? ApiConfig.RECEIVE_TIMEOUT,
      });

      const duration = Date.now() - startTime;
      hilog.info(DOMAIN, TAG, 'âœ… RESPONSE[%{public}d] (%{public}dms) => %{public}s',
        response.responseCode, duration, url);

      // å¤„ç† HTTP çŠ¶æ€ç 
      if (response.responseCode === 401) {
        await this.handleUnauthorized();
        throw new Error('Unauthorized: Token expired or invalid');
      }

      if (response.responseCode >= 400) {
        const errorBody = typeof response.result === 'string'
          ? response.result : JSON.stringify(response.result);
        hilog.error(DOMAIN, TAG, 'âŒ HTTP Error %{public}d: %{public}s',
          response.responseCode, errorBody);
        throw new Error(`HTTP Error ${response.responseCode}: ${errorBody}`);
      }

      // è§£æå“åº”
      let responseData: Object;
      if (typeof response.result === 'string') {
        responseData = JSON.parse(response.result as string) as Object;
      } else {
        responseData = response.result as Object;
      }

      // API å“åº”è§£åŒ…
      if (!options?.disableUnwrap && responseData && typeof responseData === 'object') {
        const envelope = responseData as ApiResponse<T>;
        if (envelope.success !== undefined) {
          if (envelope.success) {
            return envelope.data;
          } else {
            const errorMsg = envelope.message || 'Request failed';
            hilog.error(DOMAIN, TAG, 'âŒ API Error: %{public}s', errorMsg);
            throw new Error(errorMsg);
          }
        }
      }

      return responseData as T;
    } catch (err) {
      const duration = Date.now() - startTime;
      const errorMsg = (err instanceof Error) ? err.message : JSON.stringify(err);
      hilog.error(DOMAIN, TAG, 'âŒ REQUEST FAILED (%{public}dms) %{public}s: %{public}s',
        duration, url, errorMsg);
      if (err instanceof Error) {
        throw err;
      }
      throw new Error(errorMsg);
    } finally {
      httpRequest.destroy();
    }
  }

  // ============================================================
  // URL æ„å»º
  // ============================================================

  private buildFullUrl(endpoint: string, queryParams?: Record<string, string>): string {
    // å¦‚æœ endpoint å·²ç»æ˜¯å®Œæ•´ URL
    if (endpoint.startsWith('http://') || endpoint.startsWith('https://')) {
      return endpoint;
    }

    const baseUrl = ApiConfig.currentApiBaseUrl;
    let url = `${baseUrl}${endpoint}`;

    if (queryParams) {
      const queryString = Object.keys(queryParams)
        .filter(key => queryParams[key] !== undefined && queryParams[key] !== null)
        .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(queryParams[key])}`)
        .join('&');
      if (queryString) {
        url = `${url}?${queryString}`;
      }
    }

    return url;
  }

  /**
   * æ›¿æ¢è·¯å¾„å‚æ•°
   * å¦‚ '/cities/{id}' + { id: '123' } => '/cities/123'
   */
  static replacePathParams(endpoint: string, params: Record<string, string>): string {
    let url = endpoint;
    for (const key of Object.keys(params)) {
      url = url.replace(`{${key}}`, params[key]);
    }
    return url;
  }

  // ============================================================
  // HTTP æ–¹æ³•æ˜ å°„
  // ============================================================

  private mapHttpMethod(method: string): http.RequestMethod {
    switch (method.toUpperCase()) {
      case 'GET':
        return http.RequestMethod.GET;
      case 'POST':
        return http.RequestMethod.POST;
      case 'PUT':
        return http.RequestMethod.PUT;
      case 'DELETE':
        return http.RequestMethod.DELETE;
      default:
        // PATCH ç­‰æ–¹æ³•é€šè¿‡ POST + X-HTTP-Method-Override å¤„ç†
        return http.RequestMethod.POST;
    }
  }

  // ============================================================
  // 401 å¤„ç†
  // ============================================================

  private async handleUnauthorized(): Promise<void> {
    if (this.isRedirectingToLogin) {
      return;
    }
    this.isRedirectingToLogin = true;

    hilog.warn(DOMAIN, TAG, 'ğŸ”¥ Token expired or invalid, clearing auth...');

    // æ¸…é™¤ Token
    await TokenStorageService.getInstance().clearAll();

    // è§¦å‘å¤–éƒ¨å›è°ƒï¼ˆè·³è½¬ç™»å½•é¡µç­‰ï¼‰
    if (this.onUnauthorized) {
      this.onUnauthorized();
    }

    // 1ç§’åé‡ç½®æ ‡å¿—
    setTimeout(() => {
      this.isRedirectingToLogin = false;
    }, 1000);
  }
}
