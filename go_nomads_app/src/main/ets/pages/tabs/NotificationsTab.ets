import { AppColors } from '../../common/constants/AppColors';
import { AppNotification } from '../../models/Notification';
import { NotificationService } from '../../services/NotificationService';
import { AppStorageKeys } from '../../common/constants/AppStorageKeys';

/**
 * ÈÄöÁü• Tab - 100% ËøòÂéü Flutter notifications_page.dart
 *
 * Flutter: 3 tabs (ÂÖ®ÈÉ®/Êú™ËØª/Â∑≤ËØª), accent color #1976D2
 * TabBar: labelColor accent, indicatorColor accent
 */
@Component
export struct NotificationsTab {
  @State notifications: AppNotification[] = [];
  @State isLoading: boolean = true;
  @State isRefreshing: boolean = false;
  @State currentTabIndex: number = 0;
  private tabController: TabsController = new TabsController();

  aboutToAppear(): void {
    this.loadNotifications();
  }

  async loadNotifications(): Promise<void> {
    if (!this.isRefreshing) {
      this.isLoading = true;
    }
    try {
      const svc = NotificationService.getInstance();
      const list = await svc.getAll();
      this.notifications = list;
      const unread = list.filter((n) => !n.isRead).length;
      AppStorage.set(AppStorageKeys.UNREAD_NOTIFICATION_COUNT, unread);
    } finally {
      this.isLoading = false;
      this.isRefreshing = false;
    }
  }

  markAllRead(): void {
    const updated: AppNotification[] = [];
    for (let i = 0; i < this.notifications.length; i++) {
      const n = this.notifications[i];
      const item: AppNotification = {
        id: n.id,
        type: n.type,
        title: n.title,
        body: n.body,
        isRead: true,
        createdAt: n.createdAt,
        actionUrl: n.actionUrl,
      };
      updated.push(item);
    }
    this.notifications = updated;
    AppStorage.set(AppStorageKeys.UNREAD_NOTIFICATION_COUNT, 0);
  }

  private getFilteredNotifications(type: string): AppNotification[] {
    return this.notifications.filter((n: AppNotification) => {
      if (type === 'unread') return !n.isRead;
      if (type === 'read') return n.isRead;
      return true;
    });
  }

  build() {
    Column() {
      // TabBar Âå∫Âüü - ÁôΩËâ≤ËÉåÊôØ
      Column() {
        Row() {
          // 3‰∏™ Tab
          Tabs({ barPosition: BarPosition.Start, controller: this.tabController }) {
            TabContent() {
              this.NotificationList('all')
            }
            .tabBar(this.TabItem('ÂÖ®ÈÉ®', 0))

            TabContent() {
              this.NotificationList('unread')
            }
            .tabBar(this.TabItem('Êú™ËØª', 1))

            TabContent() {
              this.NotificationList('read')
            }
            .tabBar(this.TabItem('Â∑≤ËØª', 2))
          }
          .barMode(BarMode.Fixed)
          .barWidth('75%')
          .barHeight(48)
          .onChange((index: number) => {
            this.currentTabIndex = index;
          })
          .layoutWeight(1)

          // ÂÖ®ÈÉ®Ê†áËÆ∞‰∏∫Â∑≤ËØªÊåâÈíÆ
          SymbolGlyph($r('sys.symbol.checkmark'))
            .fontSize(20)
            .fontColor([AppColors.TEXT_SECONDARY])
            .width(48)
            .height(48)
            .onClick(() => {
              this.markAllRead();
            })
        }
        .width('100%')
      }
      .width('100%')
      .backgroundColor(AppColors.WHITE)

      if (this.isLoading && !this.isRefreshing) {
        Column() { LoadingProgress().width(36).height(36) }
          .width('100%').layoutWeight(1).justifyContent(FlexAlign.Center)
      } else {
        Refresh({ refreshing: $$this.isRefreshing }) {
          this.NotificationList(this.currentFilter())
        }
        .layoutWeight(1)
        .onRefreshing(() => {
          this.isRefreshing = true;
          this.loadNotifications();
        })
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor(AppColors.BACKGROUND)
  }

  currentFilter(): string {
    if (this.currentTabIndex === 1) return 'unread';
    if (this.currentTabIndex === 2) return 'read';
    return 'all';
  }

  @Builder
  TabItem(title: string, index: number) {
    Text(title)
      .fontSize(14)
      .fontWeight(this.currentTabIndex === index ? FontWeight.Bold : FontWeight.Normal)
      .fontColor(this.currentTabIndex === index ? AppColors.ACCENT : AppColors.TEXT_SECONDARY)
  }

  @Builder
  NotificationList(type: string) {
    if (this.getFilteredNotifications(type).length === 0) {
      Column() {
        SymbolGlyph($r('sys.symbol.bell'))
          .fontSize(48)
          .fontColor([AppColors.TEXT_TERTIARY])
        Text('ÊöÇÊó†ÈÄöÁü•')
          .fontSize(16)
          .fontColor(AppColors.TEXT_TERTIARY)
          .margin({ top: 16 })
      }
      .width('100%')
      .height('100%')
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
    } else {
      List() {
        ForEach(this.getFilteredNotifications(type), (n: AppNotification) => {
          ListItem() {
            this.NotificationRow(n)
          }
        }, (n: AppNotification) => n.id)
      }
      .divider({ strokeWidth: 0.5, color: AppColors.DIVIDER, startMargin: 56, endMargin: 16 })
      .layoutWeight(1)
    }
  }

  @Builder
  NotificationRow(n: AppNotification) {
    Row() {
      Text(this.typeIcon(n.type))
        .fontSize(22).width(40).height(40).textAlign(TextAlign.Center)
        .backgroundColor(n.isRead ? '#F1F5F9' : '#F0F9FF').borderRadius(20)

      Column({ space: 3 }) {
        Text(n.title)
          .fontSize(15).fontWeight(n.isRead ? FontWeight.Normal : FontWeight.Medium)
          .fontColor(AppColors.TEXT_PRIMARY).maxLines(1)
          .textOverflow({ overflow: TextOverflow.Ellipsis })
        Text(n.body)
          .fontSize(13).fontColor(AppColors.TEXT_SECONDARY).maxLines(2)
          .textOverflow({ overflow: TextOverflow.Ellipsis })
        Text(this.formatTime(n.createdAt))
          .fontSize(12).fontColor(AppColors.TEXT_TERTIARY)
      }
      .layoutWeight(1).padding({ left: 12 }).alignItems(HorizontalAlign.Start)

      if (!n.isRead) {
        Circle().width(8).height(8).fill(AppColors.PRIMARY)
      }
    }
    .width('100%').padding({ left: 16, right: 16, top: 12, bottom: 12 })
    .backgroundColor(n.isRead ? 'transparent' : '#FAFEFF')
  }

  typeIcon(type: string): string {
    switch (type) {
      case 'meetup': return 'üéâ';
      case 'message': return 'üí¨';
      case 'review': return '‚≠ê';
      case 'follow': return 'üë§';
      default: return 'üîî';
    }
  }

  formatTime(iso: string): string {
    if (!iso) return '';
    const d = new Date(iso);
    const now = new Date();
    const diff = Math.floor((now.getTime() - d.getTime()) / 60000);
    if (diff < 1) return 'ÂàöÂàö';
    if (diff < 60) return `${diff}ÂàÜÈíüÂâç`;
    if (diff < 1440) return `${Math.floor(diff / 60)}Â∞èÊó∂Ââç`;
    return d.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
  }
}
